
LAB3_ESCLAVO.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000196  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000142  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000196  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000001c8  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000080  00000000  00000000  00000208  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000925  00000000  00000000  00000288  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000767  00000000  00000000  00000bad  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000454  00000000  00000000  00001314  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000ac  00000000  00000000  00001768  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000003d3  00000000  00000000  00001814  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000077  00000000  00000000  00001be7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000050  00000000  00000000  00001c5e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   8:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
   c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  10:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  14:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  18:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  1c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  20:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  24:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  28:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  2c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  30:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  34:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  38:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  3c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  40:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  44:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  48:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  4c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  50:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  54:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  58:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  5c:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  60:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>
  64:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61
  74:	0e 94 6b 00 	call	0xd6	; 0xd6 <main>
  78:	0c 94 9f 00 	jmp	0x13e	; 0x13e <_exit>

0000007c <__bad_interrupt>:
  7c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000080 <adc_init>:
#include <avr/io.h>
#include "adc.h"

//Configuración del ADC
void adc_init(void){
	ADMUX = (1 << REFS0);				//Referencia a AVCC (5V)
  80:	80 e4       	ldi	r24, 0x40	; 64
  82:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>
	ADCSRA = (1 << ADEN)				//Habilitar ADC
  86:	86 e8       	ldi	r24, 0x86	; 134
  88:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
  8c:	08 95       	ret

0000008e <adc_read>:
	| (1 << ADPS2) | (1 << ADPS1);		//Prescaler de 64
} 

//Selección de canal
uint16_t adc_read(uint8_t canal){
	if (canal > 7) canal = 0;						//Canal ADC, entre ADC0-ADC7
  8e:	88 30       	cpi	r24, 0x08	; 8
  90:	08 f0       	brcs	.+2      	; 0x94 <adc_read+0x6>
  92:	80 e0       	ldi	r24, 0x00	; 0
	ADMUX = (ADMUX & 0xF0) | (canal & 0x0F);		//Usa 4 bits 
  94:	ec e7       	ldi	r30, 0x7C	; 124
  96:	f0 e0       	ldi	r31, 0x00	; 0
  98:	90 81       	ld	r25, Z
  9a:	90 7f       	andi	r25, 0xF0	; 240
  9c:	8f 70       	andi	r24, 0x0F	; 15
  9e:	89 2b       	or	r24, r25
  a0:	80 83       	st	Z, r24
	ADCSRA |= (1<< ADSC);							//Inicia conversión
  a2:	ea e7       	ldi	r30, 0x7A	; 122
  a4:	f0 e0       	ldi	r31, 0x00	; 0
  a6:	80 81       	ld	r24, Z
  a8:	80 64       	ori	r24, 0x40	; 64
  aa:	80 83       	st	Z, r24
	while (ADCSRA & (1 << ADSC));					//Espera a que termine la conversión
  ac:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
  b0:	86 fd       	sbrc	r24, 6
  b2:	fc cf       	rjmp	.-8      	; 0xac <adc_read+0x1e>
	return ADC;										//Decuelve el valor entre 0-1023	
  b4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7f8078>
  b8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
  bc:	08 95       	ret

000000be <setup>:
	}
}

void setup()
{
	cli();
  be:	f8 94       	cli
	adc_init();
  c0:	0e 94 40 00 	call	0x80	; 0x80 <adc_init>
	spi_slave_init();
  c4:	0e 94 91 00 	call	0x122	; 0x122 <spi_slave_init>
	//PD0–PD7 como salida
	DDRD = 0xFF; 
  c8:	8f ef       	ldi	r24, 0xFF	; 255
  ca:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0x00;
  cc:	1b b8       	out	0x0b, r1	; 11

	sei();
  ce:	78 94       	sei
  d0:	08 95       	ret

000000d2 <mostrar_en_leds>:
}

void mostrar_en_leds(uint8_t valor)
{
	PORTD = valor;
  d2:	8b b9       	out	0x0b, r24	; 11
  d4:	08 95       	ret

000000d6 <main>:
void setup(void);
void mostrar_en_leds(uint8_t valor);

int main(void)
{
	setup();
  d6:	0e 94 5f 00 	call	0xbe	; 0xbe <setup>
	uint16_t val1, val2;
	uint8_t comando;

	while (1)
	{
		val1 = adc_read(6);
  da:	86 e0       	ldi	r24, 0x06	; 6
  dc:	0e 94 47 00 	call	0x8e	; 0x8e <adc_read>
  e0:	18 2f       	mov	r17, r24
  e2:	09 2f       	mov	r16, r25
		val2 = adc_read(7);
  e4:	87 e0       	ldi	r24, 0x07	; 7
  e6:	0e 94 47 00 	call	0x8e	; 0x8e <adc_read>
  ea:	c8 2f       	mov	r28, r24
  ec:	d9 2f       	mov	r29, r25

		comando = spi_slave_receive();
  ee:	0e 94 9a 00 	call	0x134	; 0x134 <spi_slave_receive>

		if (comando == 0xAA)
  f2:	8a 3a       	cpi	r24, 0xAA	; 170
  f4:	79 f4       	brne	.+30     	; 0x114 <main+0x3e>
		{
			SPDR = 0x55;
  f6:	85 e5       	ldi	r24, 0x55	; 85
  f8:	8e bd       	out	0x2e, r24	; 46

			spi_slave_receive(); SPDR = (val1 >> 8);
  fa:	0e 94 9a 00 	call	0x134	; 0x134 <spi_slave_receive>
  fe:	0e bd       	out	0x2e, r16	; 46
			spi_slave_receive(); SPDR = (val1 & 0xFF);
 100:	0e 94 9a 00 	call	0x134	; 0x134 <spi_slave_receive>
 104:	1e bd       	out	0x2e, r17	; 46
			spi_slave_receive(); SPDR = (val2 >> 8);
 106:	0e 94 9a 00 	call	0x134	; 0x134 <spi_slave_receive>
 10a:	de bd       	out	0x2e, r29	; 46
			spi_slave_receive(); SPDR = (val2 & 0xFF);
 10c:	0e 94 9a 00 	call	0x134	; 0x134 <spi_slave_receive>
 110:	ce bd       	out	0x2e, r28	; 46
 112:	e3 cf       	rjmp	.-58     	; 0xda <main+0x4>
		}
		else if (comando == 0xCC)
 114:	8c 3c       	cpi	r24, 0xCC	; 204
 116:	09 f7       	brne	.-62     	; 0xda <main+0x4>
		{
			uint8_t valor = spi_slave_receive();
 118:	0e 94 9a 00 	call	0x134	; 0x134 <spi_slave_receive>
			mostrar_en_leds(valor);
 11c:	0e 94 69 00 	call	0xd2	; 0xd2 <mostrar_en_leds>
 120:	dc cf       	rjmp	.-72     	; 0xda <main+0x4>

00000122 <spi_slave_init>:
#include <avr/io.h>
#include "spi_slave.h"

void spi_slave_init(void){
	//Configurar MISO como salida 
	DDRB |= (1 << PB4);									//MISO
 122:	84 b1       	in	r24, 0x04	; 4
 124:	80 61       	ori	r24, 0x10	; 16
 126:	84 b9       	out	0x04, r24	; 4
	DDRB &= ~((1 << PB3) | (1 << PB5) | (1 << PB2));	//MOSI, SCK Y SS como entrada
 128:	84 b1       	in	r24, 0x04	; 4
 12a:	83 7d       	andi	r24, 0xD3	; 211
 12c:	84 b9       	out	0x04, r24	; 4
	//Habilitar SPI en modo esclavo
	SPCR = (1 << SPE);			
 12e:	80 e4       	ldi	r24, 0x40	; 64
 130:	8c bd       	out	0x2c, r24	; 44
 132:	08 95       	ret

00000134 <spi_slave_receive>:
}

uint8_t spi_slave_receive(void){
	while (!(SPSR & (1 << SPIF)));						//Espera a que se reciba un dato
 134:	0d b4       	in	r0, 0x2d	; 45
 136:	07 fe       	sbrs	r0, 7
 138:	fd cf       	rjmp	.-6      	; 0x134 <spi_slave_receive>
	return SPDR;										//Devuelve el dato recibido
 13a:	8e b5       	in	r24, 0x2e	; 46
 13c:	08 95       	ret

0000013e <_exit>:
 13e:	f8 94       	cli

00000140 <__stop_program>:
 140:	ff cf       	rjmp	.-2      	; 0x140 <__stop_program>
